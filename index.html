<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <style>
    body {
      margin: auto;
      padding: 20px;
      background: #f5f6f8;
    }

    canvas {
      border: 1px solid #ddd;
      background: white;
      cursor: pointer;
    }
  </style>
</head>

<body>
  1. 先完成节点
  2. 再是保留意见节点
  3. 是待审批节点
  4. 不通过节点
  <div style="margin: auto; width: 100%">
    <canvas id="flowchart" width="1500px" height="700px"></canvas>
  </div>
</body>
<script>
  const canvas = document.getElementById("flowchart");
  const ctx = canvas.getContext("2d");
  const NodeStatus = {
    PENDING: "pending",
    PROCESSING: "processing",
    COMPLETED: "completed",
    ERROR: "error",
  };
  const size = {
    width: 100,
    height: 40,
  };

  // 颜色配置
  const colors = {
    [NodeStatus.PENDING]: {
      bg: "#e2e8f0",
      border: "#94a3b8",
      text: "#475569",
    },
    [NodeStatus.PROCESSING]: {
      bg: "#fef3c7",
      border: "#f59e0b",
      text: "#92400e",
    },
    [NodeStatus.COMPLETED]: {
      bg: "#d1fae5",
      border: "#10b981",
      text: "#065f46",
    },
    [NodeStatus.ERROR]: { bg: "#fee2e2", border: "#ef4444", text: "#991b1b" },
  };

  const flowchartData = {
    nodeLabel: "呈报",
    completeTime: '123',
    children: [
      {
        status: NodeStatus.COMPLETED,
        // nodeLabel: "呈报任务1",
        children: [
          {
            // nodeLabel: "通过1-1",
            status: NodeStatus.COMPLETED,
            children: [
              // {
              //   // nodeLabel: "通过1-1",
              //   status: NodeStatus.COMPLETED,
              //   children: [],
              // },
            ],
          },
          {
            status: NodeStatus.PROCESSING,
            // nodeLabel: "审核不通过1-1",
            children: [],
          },
          {
            status: NodeStatus.ERROR,
            // nodeLabel: "审核中1-3",
            children: [],
          },

        ],
      },
      {
        // nodeLabel: "呈报任务2",
        status: NodeStatus.COMPLETED,
        children: [
          {
            status: NodeStatus.COMPLETED,
            // "nodeLabel": "审核通过2-1",
            "children": []
          },
          {
            status: NodeStatus.PENDING,
            // "nodeLabel": "审核通过2-1",
            "children": []
          },
          // {
          //   status: NodeStatus.ERROR,
          //   // "nodeLabel": "审核不通过2-2",
          //   "children": []
          // },
          // {
          //   status: NodeStatus.COMPLETED,
          //   "nodeLabel": "审核通过2-3",
          //   "children": []
          // },
        ]
      },
      // {
      //   nodeLabel: "任务3",
      //   status: NodeStatus.COMPLETED,
      //   children: [
      //     {
      //       status: NodeStatus.COMPLETED,
      //       "nodeLabel": "审核通过",
      //       "children": []
      //     },
      //     {
      //       status: NodeStatus.COMPLETED,
      //       "nodeLabel": "审核通过",
      //       "children": []
      //     },
      //   ]
      // },
      {
        // nodeLabel: "任务结束4",
        status: NodeStatus.COMPLETED,
      },
      {
        // nodeLabel: "任务结束4",
        status: NodeStatus.COMPLETED,
      },
    ],
  };

  // 绘制圆角矩形
  function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();

    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(
      x + width,
      y + height,
      x + width - radius,
      y + height
    );
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
  }

  // 绘制文本
  function drawNodeText(node, color) {
    ctx.fillStyle = color.text;
    ctx.font = "12px Microsoft YaHei";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    if (!node.nodeLabel) {
      return;
    }
    const lines = node.nodeLabel.split("\n");
    const lineHeight = 14;
    const startY =
      node.y + node.height / 2 - ((lines.length - 1) * lineHeight) / 2;

    lines.forEach((line, index) => {
      ctx.fillText(
        line,
        node.x + node.width / 2,
        startY + index * lineHeight
      );
    });
  }

  // 绘制状态指示器
  function drawStatusIndicator(ctx, x, y, status) {
    const indicatorX = x + 8;
    const indicatorY = y + 8;

    if (status === NodeStatus.COMPLETED) {
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "#10b981";
      ctx.fill();

      // 绘制对勾
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(indicatorX - 2, indicatorY);
      ctx.lineTo(indicatorX, indicatorY + 2);
      ctx.lineTo(indicatorX + 2, indicatorY - 2);
      ctx.stroke();
    } else if (status === NodeStatus.PROCESSING) {
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "#f59e0b";
      ctx.fill();

      // 添加旋转动画效果
      ctx.strokeStyle = "#f59e0b";
      ctx.lineWidth = 1;
      const angle = (Date.now() / 100) % (Math.PI * 2);
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 6, angle, angle + Math.PI);
      ctx.stroke();
    } else if (status === NodeStatus.PENDING) {
      // ctx.fillStyle = colors[status]
      // ctx.fill();
    } else if (status === NodeStatus.ERROR) {
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "#ef4444";
      ctx.fill();

      // 绘制对勾
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(indicatorX - 2, indicatorY - 2);
      ctx.lineTo(indicatorX + 2, indicatorY + 2);
      ctx.moveTo(indicatorX + 2, indicatorY - 2);
      ctx.lineTo(indicatorX - 2, indicatorY + 2);
      ctx.stroke();
    }
    ctx.restore();
  }

  // 绘制背景和边框线
  function drawBackground(ctx, color) {
    ctx.fillStyle = color.bg;
    ctx.fill();
    ctx.strokeStyle = color.border;
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function drawNode(node) {
    ctx.save();

    // 绘制圆角矩形
    drawRoundedRect(ctx, node.x, node.y, node.width, node.height, 8);

    // 绘制背景和边框线
    drawBackground(ctx, colors[node.status]);

    // 绘制文本
    drawNodeText(node, colors[node.status]);

    // 绘制状态指示器
    drawStatusIndicator(ctx, node.x, node.y, node.status);

    if (node.children?.length) {
      node.children.forEach(drawNode);
    }
  }

  const minDistanceX = 80; // 最小间距
  const minDistanceY = 60; // 最小间距
  function adjustNodePositions() {
    var farestX = 0
    function adjustNodePosition(node) {
      const { x, y, children } = node
      if (children?.length) {
        const isOddLen = (children.length % 2) % 2 !== 0
        const centerIdx = Math.floor(children.length / 2);
        children.forEach((node, index) => {
          node.x = node.width + minDistanceX + x;
          farestX = node.x > farestX ? node.x : farestX
          // 中间位置前后
          node.y = (index < centerIdx) ? (y - (node.height + minDistanceY) * (centerIdx - index)) : y + (node.height + minDistanceY) * (index - centerIdx);

          // 中间位置
          node.y = !isOddLen ? (node.y + (node.height + minDistanceY) / 2) : (index == centerIdx ? y : node.y)
          if (node.children?.length) {
            adjustNodePosition(node);
          }
        });
      } else {
        farestX = node.x
      }
    }
    flowchartData.children.forEach((node, index) => {
      node.y = 700 / 2 - 20;
      node.x = !index ? 100 : farestX + node.width + minDistanceX;
      farestX = 0;
      adjustNodePosition(node);
    });
  }

  function adjustNodeSize(children) {
    children.forEach((node, index) => {
      node.width = size.width;
      node.height = size.height;
      if (node.children && node.children.length > 0) {
        adjustNodeSize(node.children);
      }
    });
  }

  // 绘制连接线
  function drawConnections() {
    // 方向向右
    function drawRightTriangle(x, y) {
      ctx.fillStyle = '#6b7280';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - 5, y - 4);
      ctx.lineTo(x - 5, y + 4);
      ctx.closePath();
      ctx.fill();
    }

    // 方向向上
    function drawUpTriangle(x, y) {
      ctx.fillStyle = '#6b7280';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - 4, y + 5);
      ctx.lineTo(x + 4, y + 5);
      ctx.closePath();
      ctx.fill();
    }

    // 方向上下
    function drawDownTriangle(x, y) {
      ctx.fillStyle = '#6b7280';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - 4, y - 5);
      ctx.lineTo(x + 4, y - 5);
      ctx.closePath();
      ctx.fill();
    }
    var uid = 0
    function drawConnection({ x, y, children, width, height, level } = node) {
      if (children?.length) {
        children.forEach((child, index) => {
          if (child.status == NodeStatus.ERROR || child.status == NodeStatus.PENDING) {
            var startX = child.x + child.width
            var startY = child.y + child.height / 2
            var endX = child.y == nextNode.y ? (startX + minDistanceX) : (startX + minDistanceX + nextNode.width / 2)
            ctx.beginPath()
            ctx.moveTo(startX, startY)
            ctx.lineTo(endX, startY)
            ctx.stroke()

            ctx.beginPath()
            ctx.moveTo(endX, startY)
            if (child.y < nextNode.y) {
              ctx.lineTo(endX, nextNode.y)
              ctx.stroke()
              drawDownTriangle(endX, nextNode.y)
            } else if (child.y == nextNode.y) {
              drawRightTriangle(endX, nextNode.y + nextNode.height / 2)
            } else if (child.y > nextNode.y) {
              ctx.lineTo(endX, nextNode.y + nextNode.height)
              ctx.stroke()
              drawUpTriangle(endX, nextNode.y + nextNode.height)
            }
          } else if (child.status == NodeStatus.COMPLETED) {
            if (children.length == 1) {
              startX = child.x + child.width
              startY = child.y + child.height / 2
              endX = startX + minDistanceX
              ctx.beginPath()
              ctx.moveTo(startX, startY)
              ctx.lineTo(endX, startY)
              ctx.stroke()
              drawRightTriangle(endX, startY)
            } else {
              if (child.y == centerY) {
                startX = child.x + child.width / 2
                startY = child.y
                ctx.beginPath()
                ctx.moveTo(startX, startY)
                ctx.lineTo(startX, startY - minDistanceY / 2)
                ctx.stroke()
                ctx.beginPath()
                ctx.moveTo(startX, startY - minDistanceY / 2)
                ctx.lineTo(completeNode.x + completeNode.width / 2, startY - minDistanceY / 2)
                ctx.stroke()
              } else if (child.y < centerY) {
                if (completeNode) {
                  endX = completeNode.x + completeNode.width / 2
                  if (!uid) {
                    startX = child.x + child.width
                    startY = child.y + child.height / 2
                    ctx.beginPath()
                    ctx.moveTo(startX, startY)
                    ctx.lineTo(endX, startY)
                    ctx.stroke()
                    ctx.beginPath()
                    ctx.moveTo(endX, startY)
                    ctx.lineTo(endX, startY + minDistanceY + completeNode.height / 2)
                    ctx.stroke()
                    drawDownTriangle(endX, startY + minDistanceY + completeNode.height / 2)
                  } else {
                    startX = child.x + child.width
                    startY = child.y + child.height / 2
                    ctx.beginPath()
                    ctx.moveTo(startX, startY)
                    ctx.lineTo(endX, startY)
                    ctx.stroke()
                  }
                  ++uid
                }
              }
            }
          } else if (child.status == NodeStatus.PROCESSING && children.some(ele => ele.status == NodeStatus.ERROR || ele.status == NodeStatus.PENDING)) {
            var startX = child.x + child.width
            var startY = child.y + child.height / 2
            var endX = child.y == nextNode.y ? (startX + minDistanceX) : (startX + minDistanceX + nextNode.width / 2)
            ctx.beginPath()
            ctx.moveTo(startX, startY)
            ctx.lineTo(endX, startY)
            ctx.stroke()
            ctx.beginPath()
            ctx.moveTo(endX, startY)
            ctx.lineTo(endX, nextNode.y + nextNode.height)
            ctx.stroke()
            drawUpTriangle(endX, nextNode.y + nextNode.height)
          }
        })
      }
    }

    const completeNode = flowchartData.completeTime ? flowchartData.children[flowchartData.children.length - 1] : null
    const centerY = flowchartData.children[0].y
    var nextNode = null
    flowchartData.children.forEach((node, index) => {
      console.log(node, node !== completeNode, completeNode)
      node.level = index + 1
      nextNode = flowchartData.children[index + 1]
      const isGather = node.children?.some(child => child.status == NodeStatus.COMPLETED)
      const childAllComplete = node.children?.every(child => child.status == NodeStatus.COMPLETED)
      if (node.children?.length && node !== completeNode) {
        if (node.children.length > 1) {
          // 子节点左侧竖直线
          var startX = node.x + node.width + minDistanceX / 2
          var startY = node.children[0].y + node.height / 2
          var endY = node.children[node.children.length - 1].y + node.height / 2
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(startX, endY);
          ctx.stroke();

          // 水平线连接到子节点
          node.children.forEach(child => {
            const childY = child.y + child.height / 2
            ctx.beginPath();
            ctx.moveTo(startX, childY);
            ctx.lineTo(child.x, childY);
            ctx.stroke();
            drawRightTriangle(child.x, childY)
          })

          // 汇聚线
          startX = startX - minDistanceX / 2
          startY = node.y + node.height / 2
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(startX + minDistanceX / 2, startY);
          ctx.stroke();

          // 如果所有节点都是已经完成的节点，并且有完成节点，子节点右侧汇聚到结束节点（子节点右侧竖直线）
          if ((!isGather || childAllComplete) && nextNode) {
            startX = node.children[0].x + node.width + minDistanceX / 2
            startY = node.children[0].y + node.height / 2
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX, endY);
            ctx.stroke();
            // 水平线连接到子节点
            node.children.forEach(child => {
              const childY = child.y + child.height / 2
              startX = child.x + child.width
              ctx.beginPath();
              ctx.moveTo(startX, childY);
              ctx.lineTo(startX + minDistanceX / 2, childY);
              ctx.stroke();
              // drawRightTriangle(child.x, childY)
            })

            // 右侧汇聚线
            startX = node.children[0].x + node.children[0].width + minDistanceX / 2
            startY = (node.children[0].y + node.children[node.children.length - 1].y) / 2 + node.height / 2
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX + minDistanceX / 2, startY);
            ctx.stroke();
            drawRightTriangle(startX + minDistanceX / 2, startY)
          }
        } else {
          var startX = node.x + node.width
          var startY = node.children[0].y + node.height / 2
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(startX + minDistanceX, startY);
          ctx.stroke();
          drawRightTriangle(startX + minDistanceX, startY)
        }
        if (isGather && (!childAllComplete || node.children.length == 1)) {
          drawConnection(node)
        }
      } else if (!node.children?.length && node !== completeNode) {
        var startX = node.x + node.width
        var startY = node.y + node.height / 2
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(startX + minDistanceX, startY);
        ctx.stroke();
        drawRightTriangle(startX + minDistanceX, startY)
      }
      nextNode = null
    });
  }

  // 绘制整个流程图
  function drawFlowchart() {
    // 清空画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 绘制节点
    flowchartData.children.forEach((node) => {
      drawNode(node);
    });

    // 绘制连接线
    drawConnections();
  }

  // 添加动画循环用于处理中状态的动画效果
  function animate() {
    const hasProcessingNodes = flowchartData.children.some(
      (n) => n.status === NodeStatus.PROCESSING
    );
    if (JSON.stringify(flowchartData).includes(NodeStatus.PROCESSING)) {
      drawFlowchart();
    }
    requestAnimationFrame(animate);
  }

  // 鼠标点击事件
  canvas.addEventListener("click", function (event) { });

  // 鼠标悬停效果
  canvas.addEventListener("mousemove", function (event) { });


  adjustNodeSize(flowchartData.children);
  adjustNodePositions();
  drawFlowchart();
  // animate();
</script>

</html>